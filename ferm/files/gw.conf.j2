{% set fqdn_ip = salt['grains.get']('fqdn_ip4')[0] -%}
{% set fastd_nat_dev = salt['network.ifacestartswith']( fqdn_ip )[0] -%}
#
# Freifunk Karlsruhe
# NAT and ebtables Rules
#

@def $FFRL_NAT_IP = {{ network.lo.ipv4.ffrl }};
@def $FFRL_IF = (
{% for gre in salt['pillar.get']('network:gre_ffka:tunnel') %}
tun-{{ gre.name }}
{% endfor %}
{% for gre in salt['pillar.get']('network:gre_ffrl:tunnel') %}
tun-{{ gre.name }}
{% endfor %}
);
@def $L2_TUNNEL_IF = (
{% for gre in salt['pillar.get']('network:gre_ffka:tunnel') %}
ftun-{{ gre.name }}
{% endfor %}
);

@def $VZFFNRMO_NAT_IP = {{ network.lo.ipv4.vzffnrmo }};
@def $VZFFNRMO_IF = (
{% for tun in salt['pillar.get']('network:tunnel:vzffnrmo', {}).keys() -%}
tun-{{ tun }}
{% endfor %}
);


@def $NAT64_NET = {{ salt['pillar.get']('network:nat64:v4_pool') }};
@def $NAT64_IF = (nat64);


domain (ip){
 table filter {
        chain FORWARD {
            mod state state (ESTABLISHED RELATED) ACCEPT;
         }
	   }
		 table mangle {
	        chain FORWARD {
					# mss = transport mtu - (batman-adv + ether) 32 - ipv4 20 - tcp 20
					{% for hoodname in salt['pillar.get']('hoods') %}
	            interface br_{{ hoodname }} outerface $FFRL_IF proto tcp tcp-flags (SYN RST) SYN TCPMSS set-mss 1328;
              interface br_{{ hoodname }} outerface $VZFFNRMO_IF proto tcp tcp-flags (SYN RST) SYN TCPMSS set-mss 1328;
              outerface br_{{ hoodname }} interface $FFRL_IF proto tcp tcp-flags (SYN RST) SYN TCPMSS set-mss 1328;
              outerface br_{{ hoodname }} interface $VZFFNRMO_IF proto tcp tcp-flags (SYN RST) SYN TCPMSS set-mss 1328;
					{% endfor %}
	        }
	   }
}


domain ip6 {
   table mangle {
        chain FORWARD {
            # mss = transport mtu - (batman-adv + ether) 32 - ipv6 40 - tcp 20
						{% for hoodname in salt['pillar.get']('hoods') %}
            interface br_{{ hoodname }} outerface $FFRL_IF proto tcp tcp-flags (SYN RST) SYN TCPMSS  clamp-mss-to-pmtu;
            interface br_{{ hoodname }} outerface $VZFFNRMO_IF proto tcp tcp-flags (SYN RST) SYN TCPMSS  clamp-mss-to-pmtu;
						{% endfor %}
        }
   }
   table filter {
        chain FORWARD {
					{% for hoodname in salt['pillar.get']('hoods') %}
              interface $FFRL_IF outerface br_{{ hoodname }} ACCEPT;
              interface $VZFFNRMO_IF outerface br_{{ hoodname }} ACCEPT;
					{% endfor %}
        }
   }
}



domain ip table nat {

	chain PREROUTING {
		interface ({{ fastd_nat_dev }}) {
			proto udp {
				mod u32 {
					u32 '0xc&0x3=0x0' mod udp dport 10000 REDIRECT to-ports 10001;
					u32 '0xc&0x3=0x1' mod udp dport 10000 REDIRECT to-ports 10002;
					u32 '0xc&0x3=0x2' mod udp dport 10000 REDIRECT to-ports 10003;
					u32 '0xc&0x3=0x3' mod udp dport 10000 REDIRECT to-ports 10004;
				}
                    	}
		}
	}

	chain POSTROUTING {
  {% for hoodname,hood in salt['pillar.get']('hoods').items() %}
  {% if hood.exit_net == "ffrl" %}
		source {{ hood.network.ipv4.net }}/{{ hood.network.ipv4.netmask }} outerface $FFRL_IF SNAT to $FFRL_NAT_IP;
  {% elif hood.exit_net == "vzffnrmo" %}
		source {{ hood.network.ipv4.net }}/{{ hood.network.ipv4.netmask }} outerface $VZFFNRMO_IF SNAT to $VZFFNRMO_NAT_IP;
  {% endif %}
  {% endfor %}
		source $NAT64_NET outerface $VZFFNRMO_IF SNAT to $VZFFNRMO_NAT_IP;
	}
}


domain eb {
	chain (INPUT FORWARD) {
		policy ACCEPT;
		proto IPv4 interface $L2_TUNNEL_IF ip-proto udp ip-sport 67:68 DROP;
		proto IPv4 interface $L2_TUNNEL_IF ip-proto udp ip-dport 67:68 DROP;
	}

	chain FORWARD {
	#	proto ARP DROP;
{% for hoodname in salt['pillar.get']('hoods') %}
		interface bat_{{ hoodname }} logical-in br_{{ hoodname }} daddr Multicast jump MULTICAST;
{% endfor %}
	}

	chain OUTPUT {
		policy ACCEPT;
	}

	chain MULTICAST {
		policy ACCEPT;
		proto IPv4 ip-proto udp ip-dst 239.192.152.143 ip-dport 6771 DROP;
	}
}
